
#' Get probe paths
#'
#' This function uses a dataset data frame and returns probe paths.
#' Returns a probe.paths class.
#' @param dataset a data frame generated by getcell.ids() or inspect.registration().
#' @id vector indicating segmented points which belongs to single probe path.
#' @surface.point real-valued, starting DV coordinate where the path should enter. Default is 0 mm (bregma surface). 
#' @cluster boolean,  if unsuprvised Gaussian clustering using mclust should be done instead of using id vector. Default is FALSE.
#' @axis character vector. Which stereotactic axeses to use for clustering. Default is c('ML', 'DV', 'AP').
#' @return output is returned in the form of probe.paths class.
#' @keywords probes
#' @export
#' @examples
#' seg<-segment(FFC_filename)
#' plot(seg$soma$x, seg$soma$y, ylim=rev(range(seg$soma$y)), asp=1, pch=16)
#' #invoke text editor to extract filter for copy paste into your script for reprodicible results.
#' edit(seg$filter)
get.probe.paths<-function(dataset, id = NULL, surface.point = 0, cluster = FALSE, axis = c('ML', 'DV', 'AP')){
  fluorophores <- list()
  for(i in unique(id)){
    if(cluster){
      clusters <- densityMclust(dataset[id == i, axis], verbose = FALSE)$classification
    }else{
      clusters<-i
    }
    
    paths<-list()
    for(j in unique(clusters)){
      ml<-dataset[id == i,][clusters == j, 'ML']
      dv<-dataset[id == i,][clusters == j, 'DV']
      ap<-dataset[id == i,][clusters == j, 'AP']
      stereo.fitted<-data.frame(ml, dv, ap)
      
      x<-dataset[id == i,][clusters == j, 'x']
      y<-dataset[id == i,][clusters == j, 'y']
      z<-as.integer(as.factor(dataset$image))[id == i][clusters == j]
      pix.fitted<-data.frame(x, y, z)
      
      lin.regress<-lm(ml ~ dv + ap)
      new.dv <- data.frame(dv = seq(surface.point, min(dv), length.out = length(dv)))
      pt<-suppressWarnings( predict(lin.regress, new.dv) )
      pt<-data.frame(ML = pt[c(1,length(pt))], DV = c(surface.point, min(dv)), AP = range(pt)/c(surface.point, min(dv))*lin.regress$coefficients[2] )
      if(any(is.na(lin.regress$coefficients)))
        pt[,is.na(lin.regress$coefficients)] <- stereo.fitted[1, is.na(lin.regress$coefficients)]
      paths[[j]] <- pt
      
      lin.regress<-lm(x ~ y + z)
      new.y <- data.frame(y = seq(surface.point, max(y), length.out = length(y)))
      pt.pix<-suppressWarnings( predict(lin.regress, new.y) )
      pt.pix<-data.frame(x = pt.pix[c(1,length(pt.pix))], y = c(surface.point, max(y)), z = range(pt.pix)/c(surface.point, min(pt.pix))*lin.regress$coefficients[2] )
      if(any(is.na(lin.regress$coefficients)))
        pt.pix[,is.na(lin.regress$coefficients)] <- pix.fitted[1, is.na(lin.regress$coefficients)]
      paths[[j]] <- cbind(paths[[j]], pt.pix)
    }
    fluorophores[[which(unique(id) == i)]] <- paths
  }
  class(fluorophores) <- "probe.paths"
  return(fluorophores)
}

lines.probe.paths<-function(probe.paths, coord.sys = 'stereotactic', ...){

  paths<-do.call("rbind", lapply(probe.paths, function(x)do.call("rbind", x)) )
  
  if(coord.sys == 'pixel'){
    arrows(paths$x[seq(1, nrow(paths), 2)], paths$y[seq(1, nrow(paths), 2)], paths$x[seq(2, nrow(paths), 2)], paths$y[seq(2, nrow(paths), 2)], ... )
  
  }else{
    
    ml<-function(ml){
      return((ml * 1000) * 97440/456/25 + (97440/2))
    }
    dv<-function(dv){
      return((8010 + dv * 1000) * 97440/456/25)
    }
    

    arrows(ml(paths$ML[seq(1, nrow(paths), 2)]), dv(paths$DV[seq(1, nrow(paths), 2)]), ml(paths$ML[seq(2, nrow(paths), 2)]), dv(paths$DV[seq(2, nrow(paths), 2)]), ... )
  }
}

tracts3d<-function(probe.paths, ...){
  
  paths<-do.call("rbind", lapply(probe.paths, function(x)do.call("rbind", x)) )
  

    ml<-function(ml){
      return(ml * 1000/25) 
    }
    dv<-function(dv){
      return((-dv * 1000/25 * 0.95) - 320/2)
    }
    
    segments3d(pax.to.allen(paths$AP)- 530/2, dv(paths$DV), ml(paths$ML), ... )
}
